{"_nodesData":[{"id":2,"text":"R"},{"id":3,"text":"R"},{"id":4,"text":"checkWinner"},{"id":5,"text":"R"},{"id":6,"text":"aiCheckWinner"},{"id":7,"text":"getCards"},{"id":8,"text":"aiPutCards"},{"id":9,"text":"?"},{"id":10,"text":"mustTakeAll"},{"id":11,"text":"takeAll"},{"id":12,"text":"beatCards"},{"id":13,"text":"aiGetCards"},{"id":14,"text":"selectCards"},{"id":16,"text":"aiMustTakeAll"},{"id":17,"text":"aiBeatCards"},{"id":18,"text":"RL"},{"id":19,"text":"RL"},{"id":20,"text":"R"},{"id":21,"text":"RL"},{"id":22,"text":"?"}],"_edgesData":[{"id":"3-7","from":3,"to":7},{"id":"3-9","from":3,"to":9},{"id":"5-13","from":5,"to":13},{"id":"18-3","from":18,"to":3},{"id":"2-18","from":2,"to":18},{"id":"2-4","from":2,"to":4},{"id":"19-2","from":19,"to":2},{"id":"19-20","from":19,"to":20},{"id":"20-21","from":20,"to":21},{"id":"20-6","from":20,"to":6},{"id":"21-5","from":21,"to":5},{"id":"5-22","from":5,"to":22},{"id":"22-14","from":22,"to":14},{"id":"22-16","from":22,"to":16},{"id":"22-17","from":22,"to":17},{"id":"9-8","from":9,"to":8},{"id":"9-10","from":9,"to":10},{"id":"9-11","from":9,"to":11},{"id":"9-12","from":9,"to":12}],"_srcData":"const { BT_STATES, SuccessLoopNode, SequenceNode, ResetSequenceNode, SelectorNode, RunningLoopNode, ExecutionNode } = bt;\n\nfunction shuffle(array) {\n  let currentIndex = array.length;\n  while (currentIndex != 0) {\n    let randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--;\n    [array[currentIndex], array[randomIndex]] = [\n      array[randomIndex], array[currentIndex]];\n  }\n}\n\nfunction cardsToStr(deck) {\n  return deck.map(card => card.suit + ' ' + card.name).join(', ')\n}\n\nclass Game {\n  deck = [];\n  playerHand = [];\n  aiHand = [];\n  playTable = [];\n\n  constructor() {\n    ['D', 'H', 'S', 'C'].forEach((suit) => {\n      ['6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'].forEach((name, index) => {\n        this.deck.push({\n          suit: suit,\n          name: name,\n          value: index\n        })\n      })\n    })\n    shuffle(this.deck);\n  }\n  //FUNC BEGIN\n\n  getCards() {\n    //CODE BEGIN\n    let cardsCount = Math.min(6 - this.playerHand.length, this.deck.length);\n    for (let i = 0; i < cardsCount; i++) {\n      this.playerHand.push(this.deck.pop());\n    }\n\n    cardsCount = Math.min(6 - this.aiHand.length, this.deck.length);\n    for (let i = 0; i < cardsCount; i++) {\n      this.aiHand.push(this.deck.pop());\n    }\n    console.log('Card in deck left: ' + this.deck.length);\n    return BT_STATES.SUCCESS;\n    //CODE END\n  };\n\n  aiPutCards() {\n    //CODE BEGIN\n    if (this.aiHand.length == 0) {\n      return BT_STATES.SUCCESS;\n    }\n    this.aiHand.sort((a, b) => a.value - b.value);\n    let card = this.aiHand.shift();\n    if (card) {\n      this.playTable.push(card);\n      while (\n        this.aiHand.length > 0 &&\n        this.playTable.length < this.playerHand.length &&\n        this.aiHand[0].value == card.value\n      ) {\n        card = this.aiHand.shift();\n        this.playTable.push(card);\n      }\n    }\n    return BT_STATES.FAILED;\n    //CODE END\n  };\n\n  mustTakeAll() {\n    //CODE BEGIN\n    for (let cardIndex in this.playTable) {\n      let aiCard = this.playTable[cardIndex];\n      if (!this.playerHand.some((playerCard) => { return (playerCard.suit == aiCard.suit) && (playerCard.value > aiCard.value); })) {\n        alert('You can not beat:\\n' + cardsToStr(this.playerHand)\n          + '\\nYou have to take all:\\n' + cardsToStr(this.playTable) + '\\nSorry.');\n        this.playerHand = this.playerHand.concat(this.playTable);\n        this.playTable.length = 0;\n        return BT_STATES.RUNNING;\n      }\n    };\n    return BT_STATES.FAILED;\n    //CODE END\n  };\n\n  takeAll() {\n    //CODE BEGIN\n    let msg = 'Will you beat all this cards:\\n' + cardsToStr(this.playTable)\n      + '\\nYour cards:\\n' + cardsToStr(this.playerHand);\n\n    if (confirm(msg)) {\n      return BT_STATES.FAILED;\n    }\n\n    this.playerHand = this.playerHand.concat(this.playTable);\n    this.playTable.length = 0;\n    return BT_STATES.RUNNING;\n    //CODE END\n  };\n\n  beatCards() {\n    //CODE BEGIN\n    let aiCard = this.playTable[0];\n    let message = 'Select card index to beat:\\n' +\n      aiCard.suit + ' ' + aiCard.name\n      + '\\n\\nYour cards:\\n' +\n    this.playerHand.map((card, index) => {\n      return index + ' - ' + card.suit + ' ' + card.name\n    }).join('\\n');\n\n    let selection = prompt(message);\n    if (selection) {\n      let playerCard = this.playerHand[parseInt(selection)];\n      if (playerCard.suit == aiCard.suit && playerCard.value > aiCard.value) {\n        this.playTable.splice(0, 1);\n        this.playerHand.splice(selection, 1);\n        if (this.playTable.length == 0)\n          return BT_STATES.SUCCESS;\n      }\n    }\n    return BT_STATES.PENDING;\n    //CODE END\n  };\n\n  checkWinner() {\n    //CODE BEGIN\n    if (this.deck.length == 0) {\n      if (this.aiHand.length == 0) {\n        return BT_STATES.FAILED;\n      }\n      if (this.playerHand.length == 0) {\n        return BT_STATES.SUCCESS;\n      }\n    }\n    return BT_STATES.RUNNING;\n    //CODE END\n  };\n\n  aiGetCards() {\n    //CODE BEGIN\n    let getCards = Math.min(6 - this.aiHand.length, this.deck.length);\n    for (let i = 0; i < getCards; i++) {\n      this.aiHand.push(this.deck.pop());\n    }\n    getCards = Math.min(6 - this.playerHand.length, this.deck.length);\n    for (let i = 0; i < getCards; i++) {\n      this.playerHand.push(this.deck.pop());\n    }\n    console.log('Card in deck left: ' + this.deck.length);\n    return BT_STATES.SUCCESS;\n    //CODE END\n  };\n\n  selectCards() {\n    //CODE BEGIN\n    if (\n      this.playerHand.length == 0 ||\n      this.aiHand.length == this.playTable.length\n    ) {\n      return BT_STATES.SUCCESS;\n    }\n    console.log('Cards on the table: ' + cardsToStr(this.playTable));\n    let message = 'Select card to put on a table:\\n' +\n      this.playerHand.map((card, index) => {\n        return index + ' - ' + card.suit + ' ' + card.name\n      }).join('\\n');\n    let selection = prompt(message);\n\n    if (selection) {\n      let playerCard = this.playerHand[parseInt(selection)];\n      if (\n        this.playTable.length == 0 ||\n        this.playTable.some((cardOnATable) => cardOnATable.value === playerCard.value)\n      ) {\n        this.playTable.push(playerCard);\n        this.playerHand.splice(selection, 1);\n      }\n    } else {\n      return BT_STATES.FAILED;\n    }\n    return BT_STATES.PENDING;\n    //CODE END\n  };\n\n  aiMustTakeAll() {\n    //CODE BEGIN\n    for (let cardIndex in this.playTable) {\n      let playerCard = this.playTable[cardIndex];\n      if (!this.aiHand.some((aiCard) => aiCard.suit == playerCard.suit && aiCard.value > playerCard.value)) {\n        alert('AI can not beat yor cards an take them all:\\n' + cardsToStr(this.playTable));\n        this.aiHand = this.aiHand.concat(this.playTable);\n        this.playTable.length = 0;\n        return BT_STATES.RUNNING;\n      }\n    };\n    return BT_STATES.FAILED;\n    //CODE END\n  };\n\n  aiBeatCards() {\n    //CODE BEGIN\n    this.aiHand.sort((a, b) => a.value - b.value);\n    let aiCardsUsed = [];\n    for (let cardIndex in this.playTable) {\n      let playerCard = this.playTable[cardIndex];\n      let aiBeatCardIndex = this.aiHand.findIndex((aiCard) => aiCard.suit == playerCard.suit && aiCard.value > playerCard.value);\n      aiCardsUsed.push(this.aiHand[aiBeatCardIndex]);\n      this.aiHand.splice(aiBeatCardIndex, 1);\n    }\n    console.log('AI used cards: ' + aiCardsUsed.map(card => card.suit + ' ' + card.name).join(','));\n    this.playTable.length = 0;\n    return BT_STATES.SUCCESS;\n    //CODE END\n  };\n\n  aiCheckWinner() {\n    //CODE BEGIN\n    if (this.deck.length == 0) {\n      if (this.playerHand.length == 0) {\n        return BT_STATES.SUCCESS;\n      }\n      if (this.aiHand.length == 0) {\n        return BT_STATES.FAILED;\n      }\n    }\n    return BT_STATES.RUNNING;\n    //CODE END\n  };\n  //FUNC END\n  //TREE BEGIN\n  tree = new RunningLoopNode([\n    new ResetSequenceNode([\n      new RunningLoopNode([\n        new ResetSequenceNode([\n          new ExecutionNode(this.getCards, this),\n          new SelectorNode([\n            new ExecutionNode(this.aiPutCards, this),\n            new ExecutionNode(this.mustTakeAll, this),\n            new ExecutionNode(this.takeAll, this),\n            new ExecutionNode(this.beatCards, this)\n          ])\n        ])\n      ]),\n      new ExecutionNode(this.checkWinner, this)\n    ]),\n    new ResetSequenceNode([\n      new RunningLoopNode([\n        new ResetSequenceNode([\n          new ExecutionNode(this.aiGetCards, this),\n          new SelectorNode([\n            new ExecutionNode(this.selectCards, this),\n            new ExecutionNode(this.aiMustTakeAll, this),\n            new ExecutionNode(this.aiBeatCards, this)\n          ])\n        ])\n      ]),\n      new ExecutionNode(this.aiCheckWinner, this)\n    ])\n  ])\n  //TREE END\n}\nconst game = new Game();\nlet state;\ndo {\n  state = game.tree.tick();\n} while (state == BT_STATES.PENDING);\n\nalert('Game over!\\n' + state);\n"}