{"_nodesData":[{"id":1,"text":"L"},{"id":2,"text":">"},{"id":3,"text":"?"},{"id":4,"text":"L"},{"id":5,"text":">"},{"id":6,"text":"playerGetCards"},{"id":7,"text":"aiGetCards"},{"id":8,"text":"aiPutCards"},{"id":9,"text":"?"},{"id":10,"text":"mustTakeAll"},{"id":11,"text":"takeAll"},{"id":12,"text":"beatCards"},{"id":13,"text":"deckIsEmpty"},{"id":14,"text":">"},{"id":15,"text":"playerHandIsEmpty"},{"id":16,"text":"aiHandIsEmpty"},{"id":17,"text":"?"},{"id":18,"text":"L"},{"id":19,"text":">"},{"id":20,"text":"aiGetCards"},{"id":21,"text":"playerGetCards"},{"id":22,"text":"selectCards"},{"id":23,"text":"?"},{"id":24,"text":"aiMustTakeAll"},{"id":25,"text":"aiBeatCards"},{"id":26,"text":"deckIsEmpty"},{"id":27,"text":">"},{"id":28,"text":"aiHandIsEmpty"},{"id":29,"text":"playerHandIsEmpty"}],"_edgesData":[{"id":"4-5","from":4,"to":5},{"id":"9-10","from":9,"to":10},{"id":"9-11","from":9,"to":11},{"id":"9-12","from":9,"to":12},{"id":"3-4","from":3,"to":4},{"id":"1-2","from":1,"to":2},{"id":"2-3","from":2,"to":3},{"id":"2-17","from":2,"to":17},{"id":"17-18","from":17,"to":18},{"id":"18-19","from":18,"to":19},{"id":"17-26","from":17,"to":26},{"id":"23-24","from":23,"to":24},{"id":"23-25","from":23,"to":25},{"id":"14-15","from":14,"to":15},{"id":"14-16","from":14,"to":16},{"id":"3-13","from":3,"to":13},{"id":"3-14","from":3,"to":14},{"id":"17-27","from":17,"to":27},{"id":"27-28","from":27,"to":28},{"id":"27-29","from":27,"to":29},{"id":"5-6","from":5,"to":6},{"id":"5-7","from":5,"to":7},{"id":"5-8","from":5,"to":8},{"id":"5-9","from":5,"to":9},{"id":"19-20","from":19,"to":20},{"id":"19-21","from":19,"to":21},{"id":"19-22","from":19,"to":22},{"id":"19-23","from":19,"to":23}],"_srcData":"const { BT_STATES, LoopNode, SuccessLoopNode, SequenceNode, ResetSequenceNode, SelectorNode, RunningLoopNode, ExecutionNode } = bt;\n\nfunction shuffle(array) {\n    let currentIndex = array.length;\n    while (currentIndex != 0) {\n        let randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex--;\n        [array[currentIndex], array[randomIndex]] = [\n            array[randomIndex], array[currentIndex]];\n    }\n}\n\nfunction cardsToStr(deck) {\n    return deck.map(card => card.suit + ' ' + card.name).join(', ')\n}\n\nclass Game {\n    deck = [];\n    playerHand = [];\n    aiHand = [];\n    playTable = [];\n    status = '';\n\n    constructor() {\n        ['D', 'H', 'S', 'C'].forEach((suit) => {\n            ['6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'].forEach((name, index) => {\n                this.deck.push({\n                    suit: suit,\n                    name: name,\n                    value: index\n                })\n            })\n        })\n        shuffle(this.deck);\n    }\n    //FUNC BEGIN\n    playerGetCards() {\n        //CODE BEGIN\n        debugger\n\n        let cardsCount = Math.min(6 - this.playerHand.length, this.deck.length);\n        for (let i = 0; i < cardsCount; i++) {\n            this.playerHand.push(this.deck.pop());\n        }\n        return BT_STATES.SUCCESS;\n        //CODE END\n    };\n\n    aiGetCards() {\n        //CODE BEGIN\n        debugger \n\n        let getCards = Math.min(6 - this.aiHand.length, this.deck.length);\n        for (let i = 0; i < getCards; i++) {\n            this.aiHand.push(this.deck.pop());\n        }\n        return BT_STATES.SUCCESS;\n        //CODE END\n    };\n\n    aiPutCards() {\n        //CODE BEGIN\n        debugger\n\n        if (this.aiHand.length == 0) {\n            return BT_STATES.FAILED;\n        }\n        this.aiHand.sort((a, b) => a.value - b.value);\n        let card = this.aiHand.shift();\n        if (card) {\n            this.playTable.push(card);\n            while (\n                this.aiHand.length > 0 &&\n                this.playTable.length < this.playerHand.length &&\n                this.aiHand[0].value == card.value\n            ) {\n                card = this.aiHand.shift();\n                this.playTable.push(card);\n            }\n        }\n        return BT_STATES.SUCCESS;\n        //CODE END\n    };\n\n    mustTakeAll() {\n        //CODE BEGIN\n        debugger\n\n        for (let cardIndex in this.playTable) {\n            let aiCard = this.playTable[cardIndex];\n            if (!this.playerHand.some((playerCard) => { return (playerCard.suit == aiCard.suit) && (playerCard.value > aiCard.value); })) {\n                alert('You can not beat:\\n' + cardsToStr(this.playerHand)\n                    + '\\nYou have to take all:\\n' + cardsToStr(this.playTable) + '\\nSorry.');\n                this.playerHand = this.playerHand.concat(this.playTable);\n                this.playTable.length = 0;\n                return BT_STATES.SUCCESS;\n            }\n        };\n        return BT_STATES.FAILED;\n        //CODE END\n    };\n\n    takeAll() {\n        //CODE BEGIN\n        debugger\n\n        let msg = 'Will you beat all this cards:\\n' + cardsToStr(this.playTable)\n            + '\\nYour cards:\\n' + cardsToStr(this.playerHand);\n\n        if (confirm(msg)) {\n            return BT_STATES.FAILED;\n        }\n\n        this.playerHand = this.playerHand.concat(this.playTable);\n        this.playTable.length = 0;\n        return BT_STATES.SUCCESS;\n        //CODE END\n    };\n\n    beatCards() {\n        //CODE BEGIN\n        debugger\n\n        let aiCard = this.playTable[0];\n        let message = 'Select card index to beat:\\n' +\n            aiCard.suit + ' ' + aiCard.name\n            + '\\n\\nYour cards:\\n' +\n            this.playerHand.map((card, index) => {\n                return index + ' - ' + card.suit + ' ' + card.name\n            }).join('\\n');\n\n        let selection = prompt(message);\n        if (selection) {\n            let playerCard = this.playerHand[parseInt(selection)];\n            if (playerCard.suit == aiCard.suit && playerCard.value > aiCard.value) {\n                this.playTable.splice(0, 1);\n                this.playerHand.splice(selection, 1);\n                if (this.playTable.length == 0)\n                    return BT_STATES.FAILED;\n            }\n        }\n        return BT_STATES.RUNNING;\n        //CODE END\n    };\n\n    deckIsEmpty() {\n        //CODE BEGIN\n        if (this.deck.length == 0) {\n            return BT_STATES.FAILED;\n        }\n        return BT_STATES.SUCCESS;\n        //CODE END\n    };\n\n    playerHandIsEmpty() {\n        //CODE BEGIN\n        if (this.playerHand.length == 0) {\n            this.status = 'Win';\n            return BT_STATES.FAILED;\n        }\n        return BT_STATES.SUCCESS;\n        //CODE END\n    };\n\n    aiHandIsEmpty() {\n        //CODE BEGIN\n        if (this.aiHand.length == 0) {\n            this.status = 'Lose';\n            return BT_STATES.FAILED;\n        }\n        return BT_STATES.SUCCESS;\n        //CODE END\n    };\n\n    selectCards() {\n        //CODE BEGIN\n        debugger\n\n        if (this.playerHand.length == 0) {\n            return BT_STATES.FAILED;\n        }\n        if (this.aiHand.length == this.playTable.length) {\n            return BT_STATES.SUCCESS;\n        }\n        // if (\n        //     this.playerHand.length == 0 ||\n        //     this.aiHand.length == this.playTable.length\n        // ) {\n        //     return BT_STATES.FAILED;\n        // }\n        console.log('Cards on the table: ' + cardsToStr(this.playTable));\n        let message = 'Select card to put on a table:\\n' +\n            this.playerHand.map((card, index) => {\n                return index + ' - ' + card.suit + ' ' + card.name\n            }).join('\\n');\n        let selection = prompt(message);\n\n        if (selection) {\n            let playerCard = this.playerHand[parseInt(selection)];\n            if (\n                this.playTable.length == 0 ||\n                this.playTable.some((cardOnATable) => cardOnATable.value === playerCard.value)\n            ) {\n                this.playTable.push(playerCard);\n                this.playerHand.splice(selection, 1);\n            }\n        } else {\n            return BT_STATES.SUCCESS;\n        }\n        return BT_STATES.RUNNING;\n        //CODE END\n    };\n\n    aiMustTakeAll() {\n        //CODE BEGIN\n        debugger\n\n        for (let cardIndex in this.playTable) {\n            let playerCard = this.playTable[cardIndex];\n            if (!this.aiHand.some((aiCard) => aiCard.suit == playerCard.suit && aiCard.value > playerCard.value)) {\n                alert('AI can not beat yor cards an take them all:\\n' + cardsToStr(this.playTable));\n                this.aiHand = this.aiHand.concat(this.playTable);\n                this.playTable.length = 0;\n                return BT_STATES.SUCCESS;\n            }\n        };\n        return BT_STATES.FAILED;\n        //CODE END\n    };\n\n    aiBeatCards() {\n        //CODE BEGIN\n        debugger\n\n        this.aiHand.sort((a, b) => a.value - b.value);\n        let aiCardsUsed = [];\n        for (let cardIndex in this.playTable) {\n            let playerCard = this.playTable[cardIndex];\n            let aiBeatCardIndex = this.aiHand.findIndex((aiCard) => aiCard.suit == playerCard.suit && aiCard.value > playerCard.value);\n            aiCardsUsed.push(this.aiHand[aiBeatCardIndex]);\n            this.aiHand.splice(aiBeatCardIndex, 1);\n        }\n        console.log('AI used cards: ' + aiCardsUsed.map(card => card.suit + ' ' + card.name).join(','));\n        this.playTable.length = 0;\n        return BT_STATES.FAILED;\n        //CODE END\n    };\n    //FUNC END\n\n    //TREE BEGIN\n    tree = new LoopNode([\n        new SequenceNode([\n            new SelectorNode([\n                new LoopNode([\n                    new SequenceNode([\n                        new ExecutionNode(this.playerGetCards, this),\n                        new ExecutionNode(this.aiGetCards, this),\n                        new ExecutionNode(this.aiPutCards, this),\n                        new SelectorNode([\n                            new ExecutionNode(this.mustTakeAll, this),\n                            new ExecutionNode(this.takeAll, this),\n                            new ExecutionNode(this.beatCards, this)\n                        ])\n                    ])\n                ]),\n                new ExecutionNode(this.deckIsEmpty, this),\n                new SequenceNode([\n                    new ExecutionNode(this.playerHandIsEmpty, this),\n                    new ExecutionNode(this.aiHandIsEmpty, this)\n                ])\n            ]),\n            new SelectorNode([\n                new LoopNode([\n                    new SequenceNode([\n                        new ExecutionNode(this.aiGetCards, this),\n                        new ExecutionNode(this.playerGetCards, this),\n                        new ExecutionNode(this.selectCards, this),\n                        new SelectorNode([\n                            new ExecutionNode(this.aiMustTakeAll, this),\n                            new ExecutionNode(this.aiBeatCards, this)\n                        ])\n                    ])\n                ]),\n                new ExecutionNode(this.deckIsEmpty, this),\n                new SequenceNode([\n                    new ExecutionNode(this.aiHandIsEmpty, this),\n                    new ExecutionNode(this.playerHandIsEmpty, this)\n                ])\n            ])\n        ])\n    ])\n    //TREE END\n}\nconst game = new Game();\nlet state;\ndo {\n    state = game.tree.tick();\n} while (state == BT_STATES.RUNNING);\n\nalert('Game status:' + game.status);\n"}